// Basic configuration: replace these placeholders with your deployed data.
// Using ethers.js v6 API (already loaded from CDN in index.html).

// TODO: Paste your Sepolia addresses after deploying via Remix.
const VULNERABLE_CONTRACT_ADDRESS = "0xVulnerableAddressHere";
const SAFE_CONTRACT_ADDRESS = "0xSafeAddressHere";
const ATTACKER_CONTRACT_ADDRESS = "0xAttackerAddressHere";

// TODO: Paste the exact ABIs generated by Remix. Minimal ABIs are provided as
// teaching defaults, but replacing them is recommended for perfect accuracy.
const VULNERABLE_ABI = [
  "function owner() view returns (address)",
  "function targetAmount() view returns (uint256)",
  "function deadline() view returns (uint256)",
  "function totalRaised() view returns (uint256)",
  "function contributions(address) view returns (uint256)",
  "function contribute() payable",
  "function refund()",
  "function withdraw()",
  "event ContributionReceived(address indexed contributor, uint256 amount)",
  "event Refunded(address indexed contributor, uint256 amount)",
  "event Withdrawn(address indexed to, uint256 amount)"
];

const SAFE_ABI = [
  "function owner() view returns (address)",
  "function targetAmount() view returns (uint256)",
  "function deadline() view returns (uint256)",
  "function totalRaised() view returns (uint256)",
  "function withdrawn() view returns (bool)",
  "function contributions(address) view returns (uint256)",
  "function contribute() payable",
  "function refund()",
  "function withdraw()",
  "event ContributionReceived(address indexed contributor, uint256 amount)",
  "event Refunded(address indexed contributor, uint256 amount)",
  "event Withdrawn(address indexed to, uint256 amount)"
];

const ATTACKER_ABI = [
  "function owner() view returns (address)",
  "function attack() payable",
  "function drainCount() view returns (uint256)",
  "function withdrawStolenFunds()"
];

// Global state
let provider;
let signer;
let currentAccount;
let vulnerableContract;
let safeContract;
let attackerContract;

const elements = {
  connectBtn: document.getElementById("connectBtn"),
  refreshBtn: document.getElementById("refreshBtn"),
  contributeBtn: document.getElementById("contributeBtn"),
  refundBtn: document.getElementById("refundBtn"),
  withdrawBtn: document.getElementById("withdrawBtn"),
  attackBtn: document.getElementById("attackBtn"),
  account: document.getElementById("account"),
  network: document.getElementById("network"),
  networkWarning: document.getElementById("networkWarning"),
  contractAddress: document.getElementById("contractAddress"),
  contractBalance: document.getElementById("contractBalance"),
  targetAmount: document.getElementById("targetAmount"),
  totalRaised: document.getElementById("totalRaised"),
  userContribution: document.getElementById("userContribution"),
  contributionAmount: document.getElementById("contributionAmount"),
  attackAmount: document.getElementById("attackAmount"),
  attackerAddress: document.getElementById("attackerAddress"),
  attackerBalance: document.getElementById("attackerBalance"),
  attackStatus: document.getElementById("attackStatus"),
  logs: document.getElementById("logs"),
};

function log(message) {
  const entry = document.createElement("div");
  entry.className = "log-entry";
  entry.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
  elements.logs.prepend(entry);
}

function getSelectedContract() {
  const selected = document.querySelector('input[name="contract"]:checked').value;
  return selected === "vuln" ? vulnerableContract : safeContract;
}

function getSelectedAddress() {
  const selected = document.querySelector('input[name="contract"]:checked').value;
  return selected === "vuln" ? VULNERABLE_CONTRACT_ADDRESS : SAFE_CONTRACT_ADDRESS;
}

async function connectWallet() {
  if (!window.ethereum) {
    log("MetaMask not found. Please install it.");
    alert("MetaMask is required to interact with the contracts.");
    return;
  }

  await window.ethereum.request({ method: "eth_requestAccounts" });
  provider = new ethers.BrowserProvider(window.ethereum);
  signer = await provider.getSigner();
  currentAccount = await signer.getAddress();
  elements.account.textContent = currentAccount;

  const network = await provider.getNetwork();
  elements.network.textContent = `${network.name} (chainId ${network.chainId})`;
  if (network.chainId !== 11155111n) {
    elements.networkWarning.textContent = "Please switch to Sepolia";
  } else {
    elements.networkWarning.textContent = "";
  }

  // Instantiate contract objects with the signer for write operations.
  vulnerableContract = new ethers.Contract(VULNERABLE_CONTRACT_ADDRESS, VULNERABLE_ABI, signer);
  safeContract = new ethers.Contract(SAFE_CONTRACT_ADDRESS, SAFE_ABI, signer);
  attackerContract = new ethers.Contract(ATTACKER_CONTRACT_ADDRESS, ATTACKER_ABI, signer);

  // Prefill attacker address field so it is easy to copy-paste.
  elements.attackerAddress.value = ATTACKER_CONTRACT_ADDRESS;

  log("Wallet connected.");
  await refreshStats();
}

async function refreshStats() {
  if (!provider) return;
  const contract = getSelectedContract();
  const contractAddr = getSelectedAddress();
  elements.contractAddress.textContent = contractAddr;

  // Display balance, target, totalRaised, and user's contribution.
  const [balanceWei, target, total] = await Promise.all([
    provider.getBalance(contractAddr),
    contract.targetAmount(),
    contract.totalRaised(),
  ]);

  const contribution = await contract.contributions(currentAccount || ethers.ZeroAddress);

  elements.contractBalance.textContent = ethers.formatEther(balanceWei);
  elements.targetAmount.textContent = ethers.formatEther(target);
  elements.totalRaised.textContent = ethers.formatEther(total);
  elements.userContribution.textContent = ethers.formatEther(contribution);

  // Attacker balance is shown for convenience.
  if (attackerContract) {
    const attackerAddr = elements.attackerAddress.value || ATTACKER_CONTRACT_ADDRESS;
    const attackerBalance = await provider.getBalance(attackerAddr);
    elements.attackerBalance.textContent = ethers.formatEther(attackerBalance);
  }
}

async function contribute() {
  const value = elements.contributionAmount.value;
  if (!value || Number(value) <= 0) {
    alert("Enter an amount in ETH");
    return;
  }

  try {
    const contract = getSelectedContract();
    const tx = await contract.contribute({ value: ethers.parseEther(value) });
    log(`Contribution tx sent: ${tx.hash}`);
    await tx.wait();
    log("Contribution confirmed");
    await refreshStats();
  } catch (err) {
    console.error(err);
    log(`Contribution failed: ${err.message}`);
  }
}

async function requestRefund() {
  try {
    const contract = getSelectedContract();
    const tx = await contract.refund();
    log(`Refund tx sent: ${tx.hash}`);
    await tx.wait();
    log("Refund processed");
    await refreshStats();
  } catch (err) {
    console.error(err);
    log(`Refund failed: ${err.message}`);
  }
}

async function ownerWithdraw() {
  try {
    const contract = getSelectedContract();
    const tx = await contract.withdraw();
    log(`Withdraw tx sent: ${tx.hash}`);
    await tx.wait();
    log("Withdraw executed");
    await refreshStats();
  } catch (err) {
    console.error(err);
    log(`Withdraw failed: ${err.message}`);
  }
}

async function runAttack() {
  const attackAmount = elements.attackAmount.value;
  const attackerAddr = elements.attackerAddress.value || ATTACKER_CONTRACT_ADDRESS;

  try {
    // Attach to whatever address the user inputs (could be redeployed)
    attackerContract = new ethers.Contract(attackerAddr, ATTACKER_ABI, signer);

    const tx = await attackerContract.attack({ value: ethers.parseEther(attackAmount || "0") });
    log(`Attack tx sent: ${tx.hash}`);
    elements.attackStatus.textContent = "pending...";
    await tx.wait();
    elements.attackStatus.textContent = "Attack confirmed (vulnerable drained if reentrancy worked).";
    log("Attack transaction mined");
  } catch (err) {
    console.error(err);
    elements.attackStatus.textContent = "Attack failed / reverted.";
    log(`Attack failed: ${err.message}`);
  }

  await refreshStats();
}

// Wire up UI actions.
elements.connectBtn.onclick = connectWallet;
elements.refreshBtn.onclick = refreshStats;
elements.contributeBtn.onclick = contribute;
elements.refundBtn.onclick = requestRefund;
elements.withdrawBtn.onclick = ownerWithdraw;
elements.attackBtn.onclick = runAttack;

document.querySelectorAll('input[name="contract"]').forEach((radio) => {
  radio.addEventListener("change", () => {
    refreshStats();
  });
});

// Optional: auto-refresh every 20 seconds once connected.
setInterval(() => {
  if (provider) refreshStats();
}, 20000);